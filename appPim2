#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <windows.h>

// Definições de limite
#define MAX_LIVROS 100
#define MAX_BIBLIOTECARIOS 10
#define MAX_CLIENTES 100
#define MAX_EMPRESTIMOS 50
#define MAX_COLABORADORES 10
#define DIAS_LIMITE 7 // Limite de dias de empréstimo
#define MAX_LOGS 100 

// Declaração de funções
void limparTela(); //Limpa a tela.
void ocultarSenha(); //Oculta a senha.
void pausar(); // Pausa a tela.
int cpfJaCadastrado(); // Verifica se o cpf está cadastrado.
void cadastrarColaborador(); // Cadastra os colaboradores.
void registrarAlteracao(); // Salva as alterações em Logs.
void exibirColaboradores(); // Exibe os clientes cadastrados.
void exibirColaboradoresAtualizar(); // exibe os colaboradores cadastrados no Log.
int validarSenhaNumerica(); // Valida se a senha contém apenas números
void atualizarColaborador(); // Atualzia o colaborador do vetor.
void deletarColaborador(); // Deleta o colaborador do vetor.
void aguardar(); // Aguarda 2 segundos antes de continuar.
int loginColaborador(); // Entra com o Login do colaborador
int loginAdmin(); // Entra com o menu ADM
void esperarTecla(); // Espera o usuário apertar uma tecla pra prosseguir.
void gerarRelatorioBibliotecario(); // Gera um relatório para o bibliotecário referente as alterações e cadastros que foram feitos.
void exibirRelatorioAdm(); // Exibe usuários que foram alterados / deletados  e a hora. 
void menuLogin(); // Responsável por escolher se vai entrar com o ADM ou com o colaborador. 
void menuAdm(); // Menu do ADM.
void menu(); // Lista com os menus.
void cadastrarBibliotecario(); // Cadastra os bibliotecários.
void exibirBibliotecarios(); //Exibe os bibliotecários cadastrados. 
void exibirBibliotecariosAtualizar(); // Exibe a lista dos bibliotecários. 
void atualizarBibliotecario(); // Atualiza o bibliotecário. 
void deletarBibliotecario(); // Deleta o bibliotecário.
void cadastrarCliente(); // Cadastra os clientes.
void exibirClientes(); // Lista os clientes cadastrados.
void exibirClientesAtualizar(); // Lista os clientes para o Log.
void atualizarCliente(); // Atualzia o cliente.
void deletarCliente(); //Deleta o cliente.
void cadastrarLivro(); // Cadastra livros.
void exibirLivros(); // Exibe todos os livros cadastrados. 
void exibirLivrosAtualizar(); //Exibe os livros para o Log.
void exibirLivrosRetirar(); // Exibe os livros retirar.
void atualizarLivro(); // Atualiza os livros.
void deletarLivro(); // Deleta um livro cadastrado.
void emprestarLivro(); // Empresta o livro (aluga).
void devolverLivro(); // Faz a devolução do livro deixando ele disponível novamente.
void menuBibliotecario(); // Exibe o menu do bibliotecário.
void menuCliente(); // Exibe o menu do cliente. 
void menuLivro(); // Exibe o menu dos livros.

/************************************************************************************************************************************************
*   todas as funções que contém a palavra atualuzar exemplo: exibirColaboradoresAtualizar, tem uma trataviva para ser                           *
*   apresentada no relatório, pois durante a criação das funções foi inserido system("pause"), ou aguardar(); para ter a interação com usuário. *
**************************************************************************************************************************************************/


// Estruturas de dados, vetores que armazenam as informações digitadas. 
typedef struct {
    int id;
    char nome[50];
    char senha[20];
    char cpf[12];  
    time_t dataCriacao;
} Colaborador;


typedef struct {
    int id;
    char nome[50];
    time_t dataCriacao;  
    time_t dataAtualizacao;
} Bibliotecario;

typedef struct {
    int id;
    char nome[50];
    time_t dataCriacao;
    time_t dataAtualizacao;
} Cliente;

typedef struct {
    int id;
    char titulo[100];
    char autor[50];
    int disponivel;
    time_t dataCriacao;
    time_t dataAtualizacao;
} Livro;

typedef struct {
    int id;
    int idCliente;
    int idLivro;
    time_t dataEmprestimo;
    time_t dataDevolucaoPrevista;
} Emprestimo;

typedef struct {
    char colaborador[50];
    char senha[50]; 
    char acao[100]; 
    char delete[100]; 
    time_t dataAlteracao; 
    int idRegistro;
} LogAlteracao;


// Variáveis globais
Bibliotecario bibliotecarios[MAX_BIBLIOTECARIOS];
Cliente clientes[MAX_CLIENTES];
Livro livros[MAX_LIVROS];
Emprestimo emprestimos[MAX_EMPRESTIMOS];
Colaborador colaboradores[MAX_COLABORADORES];
LogAlteracao logs[MAX_LOGS];


int numLogs = 0; 
int numBibliotecarios = 0;
int numClientes = 0;
int numLivros = 0;
int numEmprestimos = 0;
int numColaboradores = 0;
float valorMultaPorDia = 0.50;
int proximoId = 1;
int proximoIdBibliotecario = 1;
int proximoIdCliente = 1;
int proximoIdLivro  = 1;
int proximoIdEmprestimo = 1;


// Função para limpar a tela
void limparTela() {
    #ifdef _WIN32
        system("cls");
    #else
        system("clear");
    #endif
}

// Oculta a senha 
void ocultarSenha(char *senha) {
    int i = 0;
    char ch;

    while ((ch = _getch()) != '\r') {  // Loop até pressionar Enter
        if (ch == '\b' && i > 0) {     // Verifica se o usuário pressionou Backspace
            printf("\b \b");           // Remove o último caractere da tela
            i--;
        } else if (ch != '\b') {       // Adiciona o caractere à senha
            senha[i] = ch;
            printf("*");               // Exibe um asterisco em vez do caractere
            i++;
        }
    }

    senha[i] = '\0';  
}


//Pausa a tela
void pausar() {
    printf("Pressione Enter para continuar...");
    getchar();  // Espera por um Enter (captura a nova linha)
}


// Função para verificar se o CPF já está cadastrado
int cpfJaCadastrado(const char *cpf) {
    for (int i = 0; i < numColaboradores; i++) {
        if (strcmp(colaboradores[i].cpf, cpf) == 0) {
            return 1; // CPF encontrado
        }
    }
    return 0; // CPF não encontrado
}


// Funções de Cadastro de Colaborador (para Admin)
void cadastrarColaborador() {
    limparTela();
    if (numColaboradores < MAX_COLABORADORES) {
        Colaborador colaborador;
        colaborador.id = proximoId++; // Atribui o próximo ID disponível e incrementa o contador

        printf("Nome do Colaborador: ");
        scanf(" %[^\n]", colaborador.nome);
        getchar();  // Limpa o caractere '\n' do buffer

        // Solicita o CPF do colaborador
        printf("Digite o CPF (apenas números): ");
        scanf("%s", colaborador.cpf);

        // Verifica se o CPF contém exatamente 11 dígitos
        if (strlen(colaborador.cpf) != 11) {
            printf("\nO CPF deve conter exatamente 11 dígitos. Tente novamente!\n");
            aguardar();
            return;
        }

        // Verifica se todos os caracteres do CPF são numéricos
        for (int i = 0; i < 11; i++) {
            if (!isdigit(colaborador.cpf[i])) {
                printf("\nO CPF deve conter apenas números. Tente novamente!\n");
                aguardar();
                return;
            }
        }

        // Verifica se o CPF já está cadastrado
        if (cpfJaCadastrado(colaborador.cpf)) {
            printf("\nERRO, O CPF informado já está cadastrado.\n");
            aguardar();
            return;
        }

        printf("Insira uma senha de 4 dígitos para o usuário: ");
        ocultarSenha(colaborador.senha);  // Oculta a digitação da senha

        // Verifica se a senha está vazia.
        if (colaborador.senha[0] == '\0') {
            printf("\n\nEsse campo não pode estar vazio \n");
            aguardar();
            return;
        }

        // Verifica se a quantidade de caracteres inseridos é maior que 4 (valor mínimo).
        if (strlen(colaborador.senha) != 4) {
            printf("\nA quantidade de caracteres tem que ser 4, tente novamente!");
            aguardar();
            return;
        }

        // Verifica se todos os caracteres são numéricos
        for (int i = 0; i < 4; i++) {
            if (!isdigit(colaborador.senha[i])) {
                printf("\n\nA senha deve conter apenas números. Tente novamente!\n");
                aguardar();
                return;
            }
        }

        // Adiciona a data e hora de criação do colaborador
        time(&colaborador.dataCriacao);

        // Adiciona o novo colaborador ao array
        colaboradores[numColaboradores++] = colaborador;

        printf("\n\nColaborador cadastrado com sucesso!\n");
    } else {
        printf("\n\nNúmero máximo de colaboradores atingido!\n");
    }
    aguardar();
}

//Salva a alteração para ser exibida em um Log.
void registrarAlteracao(char nome[], char novaSenha[], const char* acao) {
    if (numLogs < MAX_LOGS) {
        // Cria um novo log de alteração
        strcpy(logs[numLogs].colaborador, nome);
        strcpy(logs[numLogs].senha, novaSenha); // Aqui estamos armazenando a nova senha
        strcpy(logs[numLogs].acao, acao);
        logs[numLogs].dataAlteracao = time(NULL); // Registra o horário atual
        numLogs++;
    } else {
        printf("\n\nLimite de logs atingido!\n");
    }
}


// Função para exibir os colaboradores cadastrados
void exibirColaboradores() {
    //limparTela();
    printf("Colaboradores cadastrados:\n\n");
    for (int i = 0; i < numColaboradores; i++) {
        printf("ID: %d | Nome: %s\n", colaboradores[i].id, colaboradores[i].nome);
    }
    system("pause");
}

// Lista os colaboradores no menu de atualizar
void exibirColaboradoresAtualizar() {
    //limparTela();
    printf("Colaboradores cadastrados:\n\n");
    for (int i = 0; i < numColaboradores; i++) {
        printf("ID: %d | Nome: %s\n", colaboradores[i].id, colaboradores[i].nome);
    }
}

// Função para verificar se a senha contém apenas números e tem 4 dígitos
int validarSenhaNumerica(char *senha) {
    // Verifica se o comprimento é 4
    if (strlen(senha) != 4) {
        return 0;
    }

    // Verifica se todos os caracteres são dígitos numéricos
    for (int i = 0; i < 4; i++) {
        if (!isdigit(senha[i])) {
            return 0;
        }
    }

    return 1;
}


// Atualiza os colaboradores
void atualizarColaborador() {
    exibirColaboradoresAtualizar();
    int id;

    // Loop até receber um ID válido
    while (1) {
        printf("\nDigite o ID do colaborador que deseja atualizar (0 para cancelar): ");
        
        // Verifica se a entrada é um número inteiro
        if (scanf("%d", &id) != 1) {
            // Limpa o buffer de entrada em caso de erro
            while (getchar() != '\n'); // Limpa a entrada
            printf("\nEntrada inválida! Por favor, digite o ID correto.\n");
        } else if (id < 0) {
            printf("ID não pode ser negativo. Por favor, insira um ID válido.\n");
        } else {
            break; // ID válido foi digitado
        }
    }
    
    if (id > 0 && id <= numColaboradores) {
        char nomeAntigo[50], senhaAntiga[50];
        strcpy(nomeAntigo, colaboradores[id - 1].nome);  // Armazena o nome antigo
        strcpy(senhaAntiga, colaboradores[id - 1].senha);  // Armazena a senha antiga

        // Atualização do nome
        printf("Novo nome do Colaborador: ");
        char novoNome[50];
        scanf(" %[^\n]", novoNome);
        
        if (strcmp(novoNome, "") != 0 && strcmp(nomeAntigo, novoNome) != 0) {
            strcpy(colaboradores[id - 1].nome, novoNome);
            char acaoNome[100];
            snprintf(acaoNome, sizeof(acaoNome), "Nome alterado de '%s' para '%s'\n", nomeAntigo, novoNome);
            registrarAlteracao(nomeAntigo, novoNome, acaoNome);
        }

        // Atualização da senha
        printf("Insira a nova senha de 4 dígitos do usuário: ");
        char novaSenha[50];
        ocultarSenha(novaSenha);
        
        // Validação da nova senha
        if (!validarSenhaNumerica(novaSenha)) {
            printf("\nErro: A senha deve conter exatamente 4 dígitos numéricos.\n");
            aguardar();
            return;
        }

        // Verifica se a nova senha é diferente da antiga
        if (strcmp(novaSenha, "") == 0 || strcmp(senhaAntiga, novaSenha) == 0) {
            printf("\n\nA nova senha não pode ser igual à antiga ou vazia.\n");
            aguardar();
            return;  // Retorna imediatamente, impedindo a continuação da função
        } else {
            strcpy(colaboradores[id - 1].senha, novaSenha);
            char acaoSenha[100];
            snprintf(acaoSenha, sizeof(acaoSenha), "Senha alterada!\n");
            registrarAlteracao(nomeAntigo, novaSenha, acaoSenha);
        }

        printf("\n\nColaborador atualizado com sucesso!\n");
    } else {
        printf("\n\nColaborador não encontrado!\n");
        return;
    }

    aguardar();
}


//Função responsável por deletar os colaboradores.
void deletarColaborador() {
    exibirColaboradoresAtualizar(); // Exibe os colaboradores

    int id;
    printf("\nDigite o ID do colaborador que deseja deletar (0 para cancelar): ");
    scanf("%d", &id);

    if (id > 0 && id <= numColaboradores) {
        char nomeDeletado[50];
        strcpy(nomeDeletado, colaboradores[id - 1].nome); // Armazena o colaborador a ser deletado

        // Desloca todos os colaboradores após o ID para a esquerda
        for (int i = id - 1; i < numColaboradores - 1; i++) {
            colaboradores[i] = colaboradores[i + 1];
        }
        numColaboradores--; // Decrementa o número de colaboradores

        // Registra a alteração nos logs
        time_t agora;
        time(&agora);
        char horaDeletado[26];
        strftime(horaDeletado, sizeof(horaDeletado), "%Y-%m-%d %H:%M:%S", localtime(&agora));

        char acao[150];
        snprintf(acao, sizeof(acao), "'%s' deletado em %s\n", nomeDeletado, horaDeletado);
        registrarAlteracao(nomeDeletado, "", acao); // Registra a ação de deletar

        printf("\nColaborador deletado com sucesso!\n");
    } else {
        printf("Colaborador não encontrado!\n");
    }

    aguardar();
}


// Função que faz esperar 2 segundos antes de seguir
void aguardar() {
    _sleep(2000); 
    limparTela();
}

// Função de Login para Usuário
int loginColaborador() {
    char nome[50], senha[20];
    int usuarioEncontrado = 0;  // Variável para marcar se o usuário foi encontrado
    printf("Digite seu nome de usuário: ");
    scanf(" %[^\n]", nome);
    getchar();  // Limpa o caractere '\n' do buffer
    printf("Digite sua senha: ");
    ocultarSenha(senha);  // Oculta a senha ao digitar

    for (int i = 0; i < numColaboradores; i++) {
        if (strcmp(colaboradores[i].nome, nome) == 0) {
            usuarioEncontrado = 1;  // Usuário encontrado
            if (strcmp(colaboradores[i].senha, senha) == 0) {
                // Registra a data e hora de autenticação
                time_t agora = time(NULL);
                char buffer[26];
                struct tm* tm_info;
                tm_info = localtime(&agora);
                strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);

                printf("\n\nLogin realizado com sucesso!\n\n");
                printf("Data e Hora de Autenticação: %s\n", buffer);

                aguardar();
                return 1; // Login válido
            } else {
                printf("\n\nSenha incorreta!\n");
                aguardar();
                return 0; // Senha incorreta
            }
        }
    }

    if (!usuarioEncontrado) {
        printf("\n\nUsuário não encontrado!\n");
    }
    
    aguardar();
    return 0; // Login inválido
}


// Função de Login para Administrador
int loginAdmin() {
    char nome[20], senha[20];
    const char adminNome[] = "admin";
    const char adminSenha[] = "1234";

    printf("Digite o nome de usuário (admin): ");
    scanf(" %[^\n]", nome);
    getchar();  // Limpa o caractere '\n' do buffer
    printf("Digite a senha: ");
    ocultarSenha(senha);

 if (strcmp(nome, adminNome) == 0) {
    if (strcmp(senha, adminSenha) == 0) {
        esperarTecla();
        return 1;
    } else {
        printf("\n\nSenha incorreta, tente novamente!\n");
        aguardar();
        return 0;
    }
} else {
    printf("\n\nUsuário não encontrado, tente novamente!\n");
    aguardar();
    return 0;
}
}


//função pra esperar a tecla.
void esperarTecla() {
    printf("\n\nEntrando...\n");
    _sleep(2000);  // Espera 2000 milissegundos (2 segundos)
    limparTela();
}


//Função para gerar o relatório dos Bibliotecarios. 
void gerarRelatorioBibliotecario() {
    printf("Relatório de todos os registros:\n\n");

    exibirBibliotecarios();
    exibirClientes();
    exibirLivros();

    limparTela();

    // Verifica se há registros de alterações
    if (numLogs == 0) {
        printf("\nNenhuma alteração registrada.\n");
    } else {
        // Exibe o histórico de alterações com datas e horas
        printf("\nHistórico de Alterações:\n\n");
        for (int i = 0; i < numLogs; i++) {
            // Converte o tempo para uma string legível
            char buffer[26];
            struct tm* tm_info;
            tm_info = localtime(&logs[i].dataAlteracao);
            strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);  // Formato de data e hora

            // Exibe os detalhes da alteração
            printf("********************************************************\n");
            printf("Colaborador: %s\n", logs[i].colaborador);
            printf("Ação: %s\n", logs[i].acao);
            printf("ID do Registro: %d\n", logs[i].idRegistro);
            printf("Data/Hora: %s\n\n", buffer);
            printf("********************************************************\n");
        }
    }
    system("pause");
}

// Gera o relatório do Administrador
void exibirRelatorioAdm() {
    printf("Relatório de alterações dos usuários:\n\n");
    if (numLogs == 0) {
        printf("Nenhuma alteração registrada.\n\n");
        system("pause");
        return;
    }

    for (int i = 0; i < numLogs; i++) {
        // Converte o tempo para uma string legível
        char buffer[26];
        struct tm* tm_info;

        tm_info = localtime(&logs[i].dataAlteracao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("Colaborador: %s \nAção: %sData/Hora: %s\n", logs[i].colaborador, logs[i].acao, buffer);
        printf("********************************************************\n");
    }

    system("pause");
}

// Exibe as opções para entrar com o usuário adm ou com o do colaborador
void menuLogin() {
    int opcao;
    do {
        limparTela();
        printf("********************************************\n");
        printf("*            Sistema de Biblioteca         *\n");
        printf("********************************************\n\n");
        printf("1. Entrar como Administrador\n");
        printf("2. Entrar como Usuário\n");
        printf("0. Sair\n\n");
        printf("Escolha uma opção: ");

        if (scanf("%d", &opcao) != 1) {
            printf("\nOpção inválida! Por favor, insira um número entre 0 e 2.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            continue;
        }

        switch (opcao) {
            case 1:
                limparTela();
                if (loginAdmin()) {
                    menuAdm();
                }
                break;
            case 2:
                limparTela();
                if (loginColaborador()) {
                    menu(); // Acessa o menu de usuário
                }
                break;
            case 0:
                printf("Saindo...\n");
                break;
            default:
                printf("\nOpção inválida! Por favor, insira um número entre 0 e 2.\n");
                aguardar();
        }
    } while (opcao != 0);
}

// Lista o menu adm
void menuAdm() {
    int escolha;
    do {
        limparTela();
        printf("Menu do Administrador:\n\n");
        printf("1. Cadastrar Colaborador\n");
        printf("2. Exibir Colaboradores\n");
        printf("3. Atualizar Colaborador\n");
        printf("4. Deletar Colaborador\n");
        printf("5. Gerar Relatório\n");
        printf("0. Deslogar\n\n");
        printf("Escolha uma opção: ");

        if (scanf("%d", &escolha) != 1) {
            printf("\nEscolha incorreta! Por favor, insira um número entre 0 e 5.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            continue;
        }

        limparTela();

        switch (escolha) {
            case 1:
                cadastrarColaborador();
                break;
            case 2:
                exibirColaboradores();
                break;
            case 3:
                atualizarColaborador();
                break;
            case 4:
                deletarColaborador();
                break;
            case 5:
                exibirRelatorioAdm();
                break;
            case 0:
                break; // Volta ao menu anterior
            default:
                printf("\nEscolha incorreta! Por favor, insira um número entre 0 e 5.\n");
                aguardar();
        }
    } while (escolha != 0);
}

// Menu principal do usuário
void menu() {
    int opcao;
    do {
        limparTela();
        printf("********************************************\n");
        printf("*            Sistema de Biblioteca         *\n");
        printf("********************************************\n\n");
        printf("1. Menu Bibliotecário\n");
        printf("2. Menu Cliente\n");
        printf("3. Menu Livro\n");
        printf("4. Emprestar Livro\n");
        printf("5. Devolver Livro\n");
        printf("6. Gerar Relatório\n");
        printf("0. Sair\n");
        printf("\nEscolha uma opção: ");

        if (scanf("%d", &opcao) != 1) {
            printf("\nOpção inválida! Por favor, insira um número entre 0 e 6.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            menu();
        }

        switch (opcao) {
            case 1:
                menuBibliotecario();
                break;
            case 2:
                menuCliente();
                break;
            case 3:
                menuLivro();
                break;
            case 4:
                emprestarLivro();
                break;
            case 5:
                devolverLivro();
                break;
            case 6:
                gerarRelatorioBibliotecario();
                break;
            case 0:
                printf("Saindo...\n");
                break;
            default:
                printf("Opção inválida!\n");
                aguardar();
        }
    } while (opcao != 0);
}


// Funções de CRUD para Bibliotecário
void cadastrarBibliotecario() {
    if (numBibliotecarios < MAX_BIBLIOTECARIOS) {
        Bibliotecario biblio;
        biblio.id = proximoIdBibliotecario++; // Atribui o próximo ID disponível e incrementa o contador

        printf("Nome do Bibliotecário: ");
        scanf(" %[^\n]", biblio.nome);

        biblio.dataCriacao = time(NULL); // Registra a data e hora de criação
        bibliotecarios[numBibliotecarios++] = biblio;

        printf("\nBibliotecário cadastrado com sucesso!\n\n");

        // Exibe a data e hora de criação
        char buffer[26];
        struct tm* tm_info;
        tm_info = localtime(&biblio.dataCriacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("Data de Criação: %s\n", buffer);
    } else {
        printf("\n\n ERRO, Limite de bibliotecários atingido!\n");
    }
    aguardar();
}

//Função que exibe os bibliotecarios
void exibirBibliotecarios() {
    limparTela();
    printf("Bibliotecários cadastrados:\n\n");
    for (int i = 0; i < numBibliotecarios; i++) {
        printf("ID: %d | Nome: %s\n", bibliotecarios[i].id, bibliotecarios[i].nome);
        printf("\n");
    }
    system("pause");
}


// Lista os bibliotecários para atualizar
void exibirBibliotecariosAtualizar() {
    limparTela();
    printf("Bibliotecários cadastrados:\n\n");
    for (int i = 0; i < numBibliotecarios; i++) {
        printf("ID: %d | Nome: %s\n", bibliotecarios[i].id, bibliotecarios[i].nome);
    }
}


// Função para atualizar bibliotecário
void atualizarBibliotecario() {
    exibirBibliotecariosAtualizar();  // Exibe lista de bibliotecários para atualização
    int id;
    printf("\nDigite o ID do bibliotecário que deseja atualizar (0 para cancelar): ");
    scanf("%d", &id);
    getchar();  // Limpa o caractere '\n' do buffer

    // Verifica se o ID é válido
    if (id > 0 && id <= numBibliotecarios) {
        char nomeAntigo[50];
        strcpy(nomeAntigo, bibliotecarios[id - 1].nome);  // Armazena o nome antigo para o log

        // Atualização do nome
        printf("\nNovo nome do Bibliotecário: ");
        scanf(" %[^\n]", bibliotecarios[id - 1].nome);

        // Registra a data e hora da atualização
        bibliotecarios[id - 1].dataAtualizacao = time(NULL);
        printf("\nBibliotecário atualizado com sucesso!\n");

        // Exibe a data e hora de atualização
        char buffer[26];
        struct tm *tm_info;
        tm_info = localtime(&bibliotecarios[id - 1].dataAtualizacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\nData de Atualização: %s\n", buffer);

        // Registra a alteração no log
        if (numLogs < MAX_LOGS) {
            // Descrição da ação
            snprintf(logs[numLogs].acao, sizeof(logs[numLogs].acao),
                     "Nome alterado de '%s' para '%s'", nomeAntigo, bibliotecarios[id - 1].nome);

            // Preenche as demais informações no log
            strcpy(logs[numLogs].colaborador, bibliotecarios[id - 1].nome);  // Nome do bibliotecário atualizado
            logs[numLogs].dataAlteracao = bibliotecarios[id - 1].dataAtualizacao;
            logs[numLogs].idRegistro = bibliotecarios[id - 1].id;  // ID do bibliotecário

            strcpy(logs[numLogs].delete, "");  // Não está deletando o usuário, deixa o campo vazio

            numLogs++;  // Incrementa o contador de logs
        } else {
            printf("Limite de logs atingido!\n");
        }
    } else {
        printf("\nBibliotecário não encontrado!\n");
    }
    aguardar();  // Pausa para aguardar ação do usuário
}



//Função responsável por deletar os bibliotecarios. 
void deletarBibliotecario() {
    exibirBibliotecariosAtualizar(); // Exibe os bibliotecários

    int id;
    printf("\nDigite o ID do bibliotecário que deseja deletar (0 para cancelar): ");
    scanf("%d", &id);

    if (id > 0 && id <= numBibliotecarios) {
        char nomeDeletado[50];
        strcpy(nomeDeletado, bibliotecarios[id - 1].nome); // Armazena o bibliotecário a ser deletado

        // Desloca todos os bibliotecários após o ID para a esquerda
        for (int i = id - 1; i < numBibliotecarios - 1; i++) {
            bibliotecarios[i] = bibliotecarios[i + 1];
        }
        numBibliotecarios--; // Decrementa o número de bibliotecários

        // Registra a alteração nos logs
        time_t agora;
        time(&agora);
        char horaDeletado[26];
        strftime(horaDeletado, sizeof(horaDeletado), "%Y-%m-%d %H:%M:%S", localtime(&agora));

        char acao[150];
        snprintf(acao, sizeof(acao), "'%s' deletado em %s\n", nomeDeletado, horaDeletado);
        registrarAlteracao(nomeDeletado, "", acao); 

        printf("\nBibliotecário deletado com sucesso!\n");
    } else {
        printf("\nBibliotecário não encontrado!\n");
        return;
    }

    aguardar();
}

// Funções de CRUD para Clientes
void cadastrarCliente() {
    if (numClientes < MAX_CLIENTES) {
        Cliente cli;
        cli.id = proximoIdCliente++; // Atribui o próximo ID disponível e incrementa o contador

        printf("Nome do Cliente: ");
        scanf(" %[^\n]", cli.nome);

        cli.dataCriacao = time(NULL); // Registra a data e hora de criação
        clientes[numClientes++] = cli;

        printf("\nCliente cadastrado com sucesso!\n");

        // Exibe a data e hora de criação
        char buffer[26];
        struct tm* tm_info;
        tm_info = localtime(&cli.dataCriacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\nData de Criação: %s\n", buffer);
    } else {
        printf("\n\nLimite de clientes atingido!\n");
    }
    aguardar();
}

//Função usada pra poder exibir os clientes
void exibirClientes() {
    limparTela();
    printf("Clientes cadastrados:\n\n");
    for (int i = 0; i < numClientes; i++) {
        printf("ID: %d | Nome: %s", clientes[i].id, clientes[i].nome);
        printf("\n");
    }
    system("pause");
}

// Lista os clientes para atualizar
void exibirClientesAtualizar() {
    limparTela();
    printf("Clientes cadastrados:\n\n");
    for (int i = 0; i < numClientes; i++) {
        printf("ID: %d | Nome: %s\n", clientes[i].id, clientes[i].nome);
    }
}

// Atualiza os clientes 
void atualizarCliente() {
    exibirClientesAtualizar();
    int id;
    printf("\nDigite o ID do cliente que deseja atualizar (0 para cancelar): ");
    scanf("%d", &id);

    if (id > 0 && id <= numClientes) {
        printf("\nNovo nome do Cliente: ");
        scanf(" %[^\n]", clientes[id - 1].nome);
        clientes[id - 1].dataAtualizacao = time(NULL);  // Registra a data e hora de atualização
        printf("\nCliente atualizado com sucesso!\n");

        // Exibe a data e hora de atualização
        char buffer[26];
        struct tm* tm_info;
        tm_info = localtime(&clientes[id - 1].dataAtualizacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\nData de Atualização: %s\n", buffer);
        aguardar();

    } else {
        printf("\nCliente não encontrado!\n");
        aguardar();
    }
    
}

// Deleta os clientes
void deletarCliente() {
    exibirClientesAtualizar();
    int id;
    printf("\nDigite o ID do cliente que deseja deletar (0 para cancelar): ");
    scanf("%d", &id);
    
    if (id > 0 && id <= numClientes) {
        for (int i = id - 1; i < numClientes - 1; i++) {
            clientes[i] = clientes[i + 1];
        }
        numClientes--;
        printf("\nCliente deletado com sucesso!\n");
    } else {
        printf("\nCliente não encontrado!\n");
    }
    aguardar();
}

// Funções de CRUD para Livros
void cadastrarLivro() {
    limparTela();
    if (numLivros < MAX_LIVROS) {
        Livro livro;
        livro.id = proximoIdLivro++; // Atribui o próximo ID disponível e incrementa o contador

        printf("Título do Livro: ");
        scanf(" %[^\n]", livro.titulo);
        
        printf("Autor do Livro: ");
        scanf(" %[^\n]", livro.autor);
        
        livro.disponivel = 1;
        livro.dataCriacao = time(NULL); // Registra a data e hora de criação
        livros[numLivros++] = livro;

        printf("\nLivro cadastrado com sucesso!\n");
        aguardar();

        // Exibe a data e hora de criação
        char buffer[26];
        struct tm* tm_info;
        tm_info = localtime(&livro.dataCriacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\nData de Criação: %s\n", buffer);
    } else {
        printf("\nLimite de livros atingido!\n");
    }
}

//Função pra exibir os livros 
void exibirLivros() {
    limparTela();
    
    int opcao;
    char termoBusca[100];
    printf("Escolha uma opção de filtro:\n");
    printf("1. Título:\n");
    printf("2. Autor:\n");
    printf("3. Disponibilidade:\n");
    printf("4. Sem Filtro\n");
    printf("\nDigite sua opção: ");
    scanf("%d", &opcao);
    
    if (opcao != 4) {
        printf("Digite o termo de busca: ");
        scanf(" %[^\n]", termoBusca);
    }
    limparTela();
    printf("Livros cadastrados:\n\n");
    for (int i = 0; i < numLivros; i++) {
        int exibir = 1;
        switch(opcao) {
            case 1:
                if (strstr(livros[i].titulo, termoBusca) == NULL) exibir = 0;
                break;
            case 2:
                if (strstr(livros[i].autor, termoBusca) == NULL) exibir = 0;
                break;
            case 3:
                if ((strcmp(termoBusca, "Sim") == 0 && !livros[i].disponivel) ||
                    (strcmp(termoBusca, "Não") == 0 && livros[i].disponivel)) exibir = 0;
                break;
            default:
                break;
        }
        if (exibir) {
            printf("ID: %d | Título: %s | Autor: %s | Disponível: %s\n", 
                livros[i].id, livros[i].titulo, livros[i].autor, livros[i].disponivel ? "Sim" : "Não");
        }
    }
    printf("\n");
    system("pause");
}

// Lista os livros para atualizar
void exibirLivrosAtualizar() {

    limparTela();
    printf("Livros cadastrados:\n\n");
    for (int i = 0; i < numLivros; i++) {
        printf("ID: %d | Título: %s | Autor: %s | Disponível: %s\n", 
            livros[i].id, livros[i].titulo, livros[i].autor, livros[i].disponivel ? "Sim" : "Não");
    }
    //system("pause");
}

// Exibe os livros para alugar
void exibirLivrosRetirar() {

    limparTela();
    printf("Livros cadastrados:\n\n");
    for (int i = 0; i < numLivros; i++) {
        printf("ID: %d | Título: %s | Autor: %s | Disponível: %s\n", 
            livros[i].id, livros[i].titulo, livros[i].autor, livros[i].disponivel ? "Sim" : "Não");
    }
    
}

// Atualiza os livros
void atualizarLivro() {
    exibirLivrosAtualizar();
    int id;
    printf("\nDigite o ID do livro que deseja atualizar (0 para cancelar): ");
    scanf("%d", &id);

    if (id > 0 && id <= numLivros) {
        printf("\nNovo título do Livro: ");
        scanf(" %[^\n]", livros[id - 1].titulo);
        printf("Novo autor do Livro: ");
        scanf(" %[^\n]", livros[id - 1].autor);
        livros[id - 1].dataAtualizacao = time(NULL);  // Registra a data e hora de atualização
        printf("\nLivro atualizado com sucesso!\n");

        // Exibe a data e hora de atualização
        char buffer[26];
        struct tm* tm_info;
        tm_info = localtime(&livros[id - 1].dataAtualizacao);
        strftime(buffer, sizeof(buffer), "%Y-%m-%d %H:%M:%S", tm_info);
        printf("\nData de Atualização: %s\n", buffer);

        aguardar();

    } else {
        printf("\nLivro não encontrado!\n");
    }
    
}

// Função CRUD para deletar os livros
void deletarLivro() {
    exibirLivrosAtualizar();
    int id;
    printf("\nDigite o ID do livro que deseja deletar (0 para cancelar): ");
    scanf("%d", &id);
    
    if (id > 0 && id <= numLivros) {
        for (int i = id - 1; i < numLivros - 1; i++) {
            livros[i] = livros[i + 1];
        }
        numLivros--;
        printf("\nLivro deletado com sucesso!\n");
    } else {
        printf("\nLivro não encontrado!\n");
    }
    aguardar();
}


// Funções para empréstimos e devoluções
void emprestarLivro() {
    if (numEmprestimos < MAX_EMPRESTIMOS) {
        int idCliente, idLivro;

        // Exibe clientes e livros disponíveis
        exibirClientesAtualizar();
        printf("\nDigite o ID do Cliente: ");
        scanf("%d", &idCliente);

        exibirLivrosRetirar();
        printf("\nDigite o ID do Livro: ");
        scanf("%d", &idLivro);

        // Verifica se o livro está disponível
        if (livros[idLivro - 1].disponivel) {
            // Registra o empréstimo
            Emprestimo emp;
            emp.id = proximoIdEmprestimo++; // Atribui o próximo ID disponível e incrementa o contador
            emp.idCliente = idCliente;
            emp.idLivro = idLivro;
            emp.dataEmprestimo = time(NULL); // Data atual
            emp.dataDevolucaoPrevista = emp.dataEmprestimo + (DIAS_LIMITE * 24 * 60 * 60);

            // Marca o livro como indisponível
            livros[idLivro - 1].disponivel = 0;
            emprestimos[numEmprestimos++] = emp;

            printf("\nEmpréstimo registrado com sucesso!\n");
            aguardar();
        } else {
            printf("\nLivro não está disponível para empréstimo.\n");
            aguardar();
        }
    } else {
        printf("\nLimite de empréstimos atingido!\n");
        aguardar();
    }
   
}


// Faz a devolução dos livros
void devolverLivro() {
    limparTela();
    exibirLivrosRetirar();  // Exibe os livros retirados e seus IDs de empréstimo
    int idEmprestimo;
    int tentativaValida = 0;  // Variável para controlar se a tentativa foi válida

    do {
        printf("\nDigite o ID do Empréstimo para devolução (veja a lista acima): ");
        if (scanf("%d", &idEmprestimo) != 1) {
            printf("\nEntrada inválida! Por favor, insira um número válido.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            continue;
        }

        if (idEmprestimo > 0 && idEmprestimo <= numEmprestimos) {
            Emprestimo emp = emprestimos[idEmprestimo - 1];
            time_t agora = time(NULL);
            double diasPassados = difftime(agora, emp.dataEmprestimo) / (60 * 60 * 24);

            // Calcular multa por atraso
            if (diasPassados > DIAS_LIMITE) {
                double multa = (diasPassados - DIAS_LIMITE) * valorMultaPorDia;
                printf("\nLivro devolvido com atraso. Multa de R$ %.2f\n", multa);
            } else {
                printf("\nLivro devolvido no prazo.\n");
            }

            // Marca o livro como disponível novamente
            livros[emp.idLivro - 1].disponivel = 1;
            printf("\nDevolução registrada com sucesso!\n");
            tentativaValida = 1;  // Marcar tentativa como válida
        } else {
            // Mensagem informativa quando o ID do empréstimo é inválido
            printf("\nEmpréstimo não encontrado. Verifique o ID do empréstimo na lista acima e tente novamente.\n");
            printf("Dica: O ID do empréstimo está associado ao livro que você retirou. Verifique o ID ao lado do livro listado.\n");
        }
    } while (!tentativaValida);  // Continua até que uma tentativa válida seja feita

    aguardar();
}


//Menu dos bibliotecarios. 
void menuBibliotecario() {
    int opcao;
    do {
        limparTela();
        printf("--- Menu Bibliotecário ---\n\n");
        printf("1. Cadastrar Bibliotecário\n");
        printf("2. Exibir Bibliotecários\n");
        printf("3. Atualizar Bibliotecário\n");
        printf("4. Deletar Bibliotecário\n");
        printf("0. Voltar\n\n");
        printf("Escolha uma opção: ");
        if (scanf("%d", &opcao) != 1) {
            printf("\nOpção inválida! Por favor, insira um número entre 0 e 4.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            continue;
        }

        switch (opcao) {
            case 1:
                limparTela();
                cadastrarBibliotecario();
                break;
            case 2:
                exibirBibliotecarios();
                break;
            case 3:
                atualizarBibliotecario();
                break;
            case 4:
                deletarBibliotecario();
                break;
            case 0:
                break;
            default:
                printf("Opção inválida!\n");
                aguardar();
        }
    } while (opcao != 0);
}


//função menu de clientes
void menuCliente() {
    int opcao;
    do {
        limparTela();
        printf("--- Menu Cliente ---\n\n");
        printf("1. Cadastrar Cliente\n");
        printf("2. Exibir Clientes\n");
        printf("3. Atualizar Cliente\n");
        printf("4. Deletar Cliente\n");
        printf("0. Voltar\n\n");
        printf("Escolha uma opção: ");

        if (scanf("%d", &opcao) != 1) {
            printf("\nOpção inválida! Por favor, insira um número entre 0 e 4.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            continue;
        }

        switch (opcao) {
            case 1:
                limparTela();
                cadastrarCliente();
                break;
            case 2:
                exibirClientes();
                break;
            case 3:
                atualizarCliente();
                break;
            case 4:
                deletarCliente();
                break;
            case 0:
                break;
            default:
                printf("Opção inválida!\n");
                aguardar();
        }
    } while (opcao != 0);
}


//Função meu livro
void menuLivro() {
    int opcao;
    do {
        limparTela();
        printf("--- Menu Livro ---\n\n");
        printf("1. Cadastrar Livro\n");
        printf("2. Exibir Livros\n");
        printf("3. Atualizar Livro\n");
        printf("4. Deletar Livro\n");
        printf("0. Voltar\n");
        printf("\nEscolha uma opção: ");

        if (scanf("%d", &opcao) != 1) {
            printf("\nOpção inválida! Por favor, insira um número entre 0 e 4.\n");
            while (getchar() != '\n'); // Limpa o buffer de entrada
            aguardar();
            continue;
        }

        switch (opcao) {
            case 1:
                limparTela();
                cadastrarLivro();
                break;
            case 2:
                exibirLivros();
                break;
            case 3:
                atualizarLivro();
                break;
            case 4:
                deletarLivro();
                break;
            case 0:
                break;
            default:
                printf("Opção inválida!\n");
                aguardar();
        }
    } while (opcao != 0);
}



int main() {
     
    // Altera a codificação do console para UTF-8 
    SetConsoleOutputCP(CP_UTF8);
    menuLogin();  // Agora inicia pelo menu de login (Admin ou Usuário)
     return 0;
}